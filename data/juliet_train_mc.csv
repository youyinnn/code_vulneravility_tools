sentence,label
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE566_Authorization_Bypass_Through_SQL_Primary__Servlet_81_bad.java
Label Definition File: CWE566_Authorization_Bypass_Through_SQL_Primary__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 566 Authorization Bypass through SQL primary
 * BadSource:  user id taken from url parameter
 * GoodSource: hardcoded user id
 * Sinks: writeConsole
 *    BadSink : user authorization not checked
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE566_Authorization_Bypass_Through_SQL_Primary;

public class CWE566_Authorization_Bypass_Through_SQL_Primary__Servlet_81_bad extends CWE566_Authorization_Bypass_Through_SQL_Primary__Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dBConnection = IO.getDBConnection();
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int id = 0;
        try {
            id = Integer.parseInt(data);
        } catch (NumberFormatException nfx) {
            id = -1;
            /* Assuming this id does not exist */
        }
        try {
            preparedStatement = dBConnection.prepareStatement(""select * from invoices where uid=?"");
            preparedStatement.setInt(1, id);
            resultSet = preparedStatement.executeQuery();
            /* POTENTIAL FLAW: no check to see whether the user has privileges to view the data */
            IO.writeString(""bad() - result requested: "" + data + ""\n"");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error executing query"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Could not close ResultSet"", exceptSql);
            }
            try {
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Could not close PreparedStatement"", exceptSql);
            }
            try {
                if (dBConnection != null) {
                    dBConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Could not close Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__Property_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__Property_81_bad extends CWE643_Xpath_Injection__Property_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__database_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__database_81_bad extends CWE643_Xpath_Injection__database_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__getQueryString_Servlet_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__getQueryString_Servlet_81_bad extends CWE643_Xpath_Injection__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__Environment_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__Environment_81_bad extends CWE643_Xpath_Injection__Environment_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__PropertiesFile_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__PropertiesFile_81_bad extends CWE643_Xpath_Injection__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__connect_tcp_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__connect_tcp_81_bad extends CWE643_Xpath_Injection__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__console_readLine_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__console_readLine_81_bad extends CWE643_Xpath_Injection__console_readLine_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__listen_tcp_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__listen_tcp_81_bad extends CWE643_Xpath_Injection__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__getCookies_Servlet_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__getCookies_Servlet_81_bad extends CWE643_Xpath_Injection__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__File_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__File_81_bad extends CWE643_Xpath_Injection__File_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__getParameter_Servlet_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__getParameter_Servlet_81_bad extends CWE643_Xpath_Injection__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__URLConnection_81_bad.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__URLConnection_81_bad extends CWE643_Xpath_Injection__URLConnection_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_listen_tcp_81_bad.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_listen_tcp_81_bad extends CWE601_Open_Redirect__Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_File_81_bad.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_File_81_bad extends CWE601_Open_Redirect__Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_database_81_bad.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_database_81_bad extends CWE601_Open_Redirect__Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_PropertiesFile_81_bad.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_PropertiesFile_81_bad extends CWE601_Open_Redirect__Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_getParameter_Servlet_81_bad.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_getParameter_Servlet_81_bad extends CWE601_Open_Redirect__Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_getCookies_Servlet_81_bad.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_getCookies_Servlet_81_bad extends CWE601_Open_Redirect__Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_getQueryString_Servlet_81_bad.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_getQueryString_Servlet_81_bad extends CWE601_Open_Redirect__Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_URLConnection_81_bad.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_URLConnection_81_bad extends CWE601_Open_Redirect__Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_connect_tcp_81_bad.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_connect_tcp_81_bad extends CWE601_Open_Redirect__Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_getQueryString_Servlet_81_bad.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_getQueryString_Servlet_81_bad extends CWE81_XSS_Error_Message__Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_File_81_bad.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_File_81_bad extends CWE81_XSS_Error_Message__Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_PropertiesFile_81_bad.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_PropertiesFile_81_bad extends CWE81_XSS_Error_Message__Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_connect_tcp_81_bad.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_connect_tcp_81_bad extends CWE81_XSS_Error_Message__Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_database_81_bad.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_database_81_bad extends CWE81_XSS_Error_Message__Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_listen_tcp_81_bad.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_listen_tcp_81_bad extends CWE81_XSS_Error_Message__Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_getParameter_Servlet_81_bad.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_getParameter_Servlet_81_bad extends CWE81_XSS_Error_Message__Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_getCookies_Servlet_81_bad.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_getCookies_Servlet_81_bad extends CWE81_XSS_Error_Message__Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_URLConnection_81_bad.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_URLConnection_81_bad extends CWE81_XSS_Error_Message__Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_URLConnection_81_bad.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s02;

public class CWE80_XSS__Servlet_URLConnection_81_bad extends CWE80_XSS__Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_PropertiesFile_81_bad.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s02;

public class CWE80_XSS__Servlet_PropertiesFile_81_bad extends CWE80_XSS__Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_getCookies_Servlet_81_bad.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_getCookies_Servlet_81_bad extends CWE80_XSS__CWE182_Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_listen_tcp_81_bad.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_listen_tcp_81_bad extends CWE80_XSS__CWE182_Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_connect_tcp_81_bad.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_connect_tcp_81_bad extends CWE80_XSS__CWE182_Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_connect_tcp_81_bad.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_connect_tcp_81_bad extends CWE80_XSS__Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_getQueryString_Servlet_81_bad.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_getQueryString_Servlet_81_bad extends CWE80_XSS__Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_listen_tcp_81_bad.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_listen_tcp_81_bad extends CWE80_XSS__Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_database_81_bad.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_database_81_bad extends CWE80_XSS__CWE182_Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_getCookies_Servlet_81_bad.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_getCookies_Servlet_81_bad extends CWE80_XSS__Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_File_81_bad.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_File_81_bad extends CWE80_XSS__Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_getParameter_Servlet_81_bad.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_getParameter_Servlet_81_bad extends CWE80_XSS__CWE182_Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_getQueryString_Servlet_81_bad.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_getQueryString_Servlet_81_bad extends CWE80_XSS__CWE182_Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_File_81_bad.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_File_81_bad extends CWE80_XSS__CWE182_Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_PropertiesFile_81_bad.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_PropertiesFile_81_bad extends CWE80_XSS__CWE182_Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_database_81_bad.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_database_81_bad extends CWE80_XSS__Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_getParameter_Servlet_81_bad.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_getParameter_Servlet_81_bad extends CWE80_XSS__Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_URLConnection_81_bad.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_URLConnection_81_bad extends CWE80_XSS__CWE182_Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__getQueryString_Servlet_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__getQueryString_Servlet_81_bad extends CWE78_OS_Command_Injection__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__getCookies_Servlet_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__getCookies_Servlet_81_bad extends CWE78_OS_Command_Injection__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__getParameter_Servlet_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__getParameter_Servlet_81_bad extends CWE78_OS_Command_Injection__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__database_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__database_81_bad extends CWE78_OS_Command_Injection__database_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__connect_tcp_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__connect_tcp_81_bad extends CWE78_OS_Command_Injection__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__console_readLine_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__console_readLine_81_bad extends CWE78_OS_Command_Injection__console_readLine_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__Property_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__Property_81_bad extends CWE78_OS_Command_Injection__Property_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__Environment_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__Environment_81_bad extends CWE78_OS_Command_Injection__Environment_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__URLConnection_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__URLConnection_81_bad extends CWE78_OS_Command_Injection__URLConnection_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__listen_tcp_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__listen_tcp_81_bad extends CWE78_OS_Command_Injection__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__PropertiesFile_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__PropertiesFile_81_bad extends CWE78_OS_Command_Injection__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__File_81_bad.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__File_81_bad extends CWE78_OS_Command_Injection__File_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_connect_tcp_81_bad.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_connect_tcp_81_bad extends CWE83_XSS_Attribute__Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_getParameter_Servlet_81_bad.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_getParameter_Servlet_81_bad extends CWE83_XSS_Attribute__Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_getCookies_Servlet_81_bad.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_getCookies_Servlet_81_bad extends CWE83_XSS_Attribute__Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_database_81_bad.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_database_81_bad extends CWE83_XSS_Attribute__Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_listen_tcp_81_bad.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_listen_tcp_81_bad extends CWE83_XSS_Attribute__Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_PropertiesFile_81_bad.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_PropertiesFile_81_bad extends CWE83_XSS_Attribute__Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_File_81_bad.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_File_81_bad extends CWE83_XSS_Attribute__Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_URLConnection_81_bad.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_URLConnection_81_bad extends CWE83_XSS_Attribute__Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_getQueryString_Servlet_81_bad.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_getQueryString_Servlet_81_bad extends CWE83_XSS_Attribute__Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__System_getProperty_trim_81_bad.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: System_getProperty Set data to return of System.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__System_getProperty_trim_81_bad extends CWE690_NULL_Deref_From_Return__System_getProperty_trim_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.trim();
        IO.writeLine(stringTrimmed);
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Class_String_81_bad.java
Label Definition File: CWE690_NULL_Deref_From_Return__Class.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource:  Use a custom method which may return null
 * GoodSource: Use a custom method that never returns null
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Class_String_81_bad extends CWE690_NULL_Deref_From_Return__Class_String_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.trim();
        IO.writeLine(stringTrimmed);
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Properties_getProperty_trim_81_bad.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: Properties_getProperty Set data to return of Properties.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Properties_getProperty_trim_81_bad extends CWE690_NULL_Deref_From_Return__Properties_getProperty_trim_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.trim();
        IO.writeLine(stringTrimmed);
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__getParameter_Servlet_trim_81_bad.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: getParameter_Servlet Set data to return of getParameter_Servlet
 * GoodSource: Set data to fixed, non-null String
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__getParameter_Servlet_trim_81_bad extends CWE690_NULL_Deref_From_Return__getParameter_Servlet_trim_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.trim();
        IO.writeLine(stringTrimmed);
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__getParameter_Servlet_equals_81_bad.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: getParameter_Servlet Set data to return of getParameter_Servlet
 * GoodSource: Set data to fixed, non-null String
 * Sinks: equals
 *    GoodSink: Call equals() on string literal (that is not null)
 *    BadSink : Call equals() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__getParameter_Servlet_equals_81_bad extends CWE690_NULL_Deref_From_Return__getParameter_Servlet_equals_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        if (data.equals(""CWE690"")) {
            IO.writeLine(""data is CWE690"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Properties_getProperty_equals_81_bad.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: Properties_getProperty Set data to return of Properties.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: equals
 *    GoodSink: Call equals() on string literal (that is not null)
 *    BadSink : Call equals() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Properties_getProperty_equals_81_bad extends CWE690_NULL_Deref_From_Return__Properties_getProperty_equals_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        if (data.equals(""CWE690"")) {
            IO.writeLine(""data is CWE690"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Class_StringBuilder_81_bad.java
Label Definition File: CWE690_NULL_Deref_From_Return__Class.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource:  Use a custom method which may return null
 * GoodSource: Use a custom method that never returns null
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Class_StringBuilder_81_bad extends CWE690_NULL_Deref_From_Return__Class_StringBuilder_81_base {

    public void action(StringBuilder data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.toString().trim();
        IO.writeLine(stringTrimmed);
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__System_getProperty_equals_81_bad.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: System_getProperty Set data to return of System.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: equals
 *    GoodSink: Call equals() on string literal (that is not null)
 *    BadSink : Call equals() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__System_getProperty_equals_81_bad extends CWE690_NULL_Deref_From_Return__System_getProperty_equals_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        if (data.equals(""CWE690"")) {
            IO.writeLine(""data is CWE690"");
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__listen_tcp_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__listen_tcp_81_bad extends CWE23_Relative_Path_Traversal__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__console_readLine_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__console_readLine_81_bad extends CWE23_Relative_Path_Traversal__console_readLine_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__URLConnection_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__URLConnection_81_bad extends CWE23_Relative_Path_Traversal__URLConnection_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__getParameter_Servlet_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__getParameter_Servlet_81_bad extends CWE23_Relative_Path_Traversal__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__File_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__File_81_bad extends CWE23_Relative_Path_Traversal__File_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__PropertiesFile_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__PropertiesFile_81_bad extends CWE23_Relative_Path_Traversal__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__getQueryString_Servlet_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__getQueryString_Servlet_81_bad extends CWE23_Relative_Path_Traversal__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__getCookies_Servlet_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__getCookies_Servlet_81_bad extends CWE23_Relative_Path_Traversal__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__Environment_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__Environment_81_bad extends CWE23_Relative_Path_Traversal__Environment_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__connect_tcp_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__connect_tcp_81_bad extends CWE23_Relative_Path_Traversal__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__Property_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__Property_81_bad extends CWE23_Relative_Path_Traversal__Property_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__database_81_bad.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__database_81_bad extends CWE23_Relative_Path_Traversal__database_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__database_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__database_81_bad extends CWE36_Absolute_Path_Traversal__database_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__Environment_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__Environment_81_bad extends CWE36_Absolute_Path_Traversal__Environment_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__PropertiesFile_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__PropertiesFile_81_bad extends CWE36_Absolute_Path_Traversal__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__console_readLine_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__console_readLine_81_bad extends CWE36_Absolute_Path_Traversal__console_readLine_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__getQueryString_Servlet_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__getQueryString_Servlet_81_bad extends CWE36_Absolute_Path_Traversal__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__connect_tcp_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__connect_tcp_81_bad extends CWE36_Absolute_Path_Traversal__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__getParameter_Servlet_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__getParameter_Servlet_81_bad extends CWE36_Absolute_Path_Traversal__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__File_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__File_81_bad extends CWE36_Absolute_Path_Traversal__File_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__Property_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__Property_81_bad extends CWE36_Absolute_Path_Traversal__Property_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__URLConnection_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__URLConnection_81_bad extends CWE36_Absolute_Path_Traversal__URLConnection_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__listen_tcp_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__listen_tcp_81_bad extends CWE36_Absolute_Path_Traversal__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__getCookies_Servlet_81_bad.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__getCookies_Servlet_81_bad extends CWE36_Absolute_Path_Traversal__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__console_readLine_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__console_readLine_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__console_readLine_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__Environment_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__Environment_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__Environment_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__getQueryString_Servlet_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__getQueryString_Servlet_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__getCookies_Servlet_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__getCookies_Servlet_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__File_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__File_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__File_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__URLConnection_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__URLConnection_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__URLConnection_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__PropertiesFile_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__PropertiesFile_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__getParameter_Servlet_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__getParameter_Servlet_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__Property_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__Property_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__Property_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__database_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__database_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__database_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__listen_tcp_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__listen_tcp_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__connect_tcp_81_bad.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__connect_tcp_81_bad extends CWE15_External_Control_of_System_or_Configuration_Setting__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE
"/*
 * @description Public static fields should be marked final.  If they are not, they
 * may be manipulated in unexpected ways.
 *
 * This class contains the ""bad"" version.
 * There is no need to implement the bad() and good() methods in this test case.
 *
 * */
package testcases.CWE500_Public_Static_Field_Not_Final;

public class CWE500_Public_Static_Field_Not_Final__String_01_bad extends AbstractTestCaseClassIssueBad implements Cloneable {

    /* FLAW: public static fields should be marked final */
    public static String DEFAULT_ERROR = ""The value you entered was not understood.  Please try again."";

    public void bad() {
        IO.writeLine(DEFAULT_ERROR);
    }

    /* Below is the main(). It is only used when building this testcase on
     * its own for testing or for building a binary to use in testing binary
     * analysis tools. It is not used when compiling all the testcases as one
     * application, which is how source code analysis tools are tested.
	 */
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        mainFromParent(args);
    }
}
",CWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_ArrayList_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashMap_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashSet_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__listen_tcp_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__listen_tcp_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__listen_tcp_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashMap_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashSet_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__max_value_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: max_value Set data to a hardcoded value of Integer.MAX_VALUE
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__max_value_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__max_value_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashMap_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__max_value_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: max_value Set data to a hardcoded value of Integer.MAX_VALUE
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__max_value_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__max_value_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_ArrayList_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashSet_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__max_value_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: max_value Set data to a hardcoded value of Integer.MAX_VALUE
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__max_value_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__max_value_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_ArrayList_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Environment_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__Environment_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__Environment_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__File_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__File_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__File_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__database_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__database_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__database_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Environment_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__Environment_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__Environment_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: console_readLine Read data from the console using readLine
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Environment_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__Environment_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__Environment_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__File_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__File_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__File_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__database_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__database_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__database_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__database_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__database_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__database_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__File_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__File_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__File_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__console_readLine_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: console_readLine Read data from the console using readLine
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__console_readLine_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__console_readLine_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__connect_tcp_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__connect_tcp_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__connect_tcp_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: console_readLine Read data from the console using readLine
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Property_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__Property_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__Property_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__random_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: random Set data to a random value
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__random_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__random_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Property_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__Property_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__Property_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Property_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__Property_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__Property_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__URLConnection_ArrayList_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__URLConnection_ArrayList_81_bad extends CWE789_Uncontrolled_Mem_Alloc__URLConnection_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__random_HashSet_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: random Set data to a random value
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__random_HashSet_81_bad extends CWE789_Uncontrolled_Mem_Alloc__random_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__random_HashMap_81_bad.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: random Set data to a random value
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__random_HashMap_81_bad extends CWE789_Uncontrolled_Mem_Alloc__random_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",CWE789
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_executeQuery_81_bad extends CWE89_SQL_Injection__File_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_executeBatch_81_bad extends CWE89_SQL_Injection__getCookies_Servlet_executeBatch_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_prepareStatement_81_bad extends CWE89_SQL_Injection__File_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getParameter_Servlet_executeQuery_81_bad extends CWE89_SQL_Injection__getParameter_Servlet_executeQuery_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_executeUpdate_81_bad extends CWE89_SQL_Injection__File_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_execute_81_bad extends CWE89_SQL_Injection__File_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_executeQuery_81_bad extends CWE89_SQL_Injection__Environment_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getParameter_Servlet_executeBatch_81_bad extends CWE89_SQL_Injection__getParameter_Servlet_executeBatch_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_prepareStatement_81_bad extends CWE89_SQL_Injection__getCookies_Servlet_prepareStatement_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_execute_81_bad extends CWE89_SQL_Injection__getCookies_Servlet_execute_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_executeBatch_81_bad extends CWE89_SQL_Injection__File_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_execute_81_bad extends CWE89_SQL_Injection__Environment_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_executeUpdate_81_bad extends CWE89_SQL_Injection__getCookies_Servlet_executeUpdate_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_executeUpdate_81_bad extends CWE89_SQL_Injection__Environment_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_executeQuery_81_bad extends CWE89_SQL_Injection__getCookies_Servlet_executeQuery_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_prepareStatement_81_bad extends CWE89_SQL_Injection__Environment_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_executeQuery_81_bad extends CWE89_SQL_Injection__console_readLine_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_execute_81_bad extends CWE89_SQL_Injection__console_readLine_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_execute_81_bad extends CWE89_SQL_Injection__database_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_executeUpdate_81_bad extends CWE89_SQL_Injection__console_readLine_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__Environment_executeBatch_81_bad extends CWE89_SQL_Injection__Environment_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_prepareStatement_81_bad extends CWE89_SQL_Injection__console_readLine_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_prepareStatement_81_bad extends CWE89_SQL_Injection__connect_tcp_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_executeQuery_81_bad extends CWE89_SQL_Injection__database_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_execute_81_bad extends CWE89_SQL_Injection__connect_tcp_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_prepareStatement_81_bad extends CWE89_SQL_Injection__database_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_executeBatch_81_bad extends CWE89_SQL_Injection__console_readLine_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_executeBatch_81_bad extends CWE89_SQL_Injection__database_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_executeUpdate_81_bad extends CWE89_SQL_Injection__connect_tcp_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_executeBatch_81_bad extends CWE89_SQL_Injection__connect_tcp_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_executeUpdate_81_bad extends CWE89_SQL_Injection__database_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_executeQuery_81_bad extends CWE89_SQL_Injection__connect_tcp_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_executeBatch_81_bad extends CWE89_SQL_Injection__Property_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_prepareStatement_81_bad extends CWE89_SQL_Injection__URLConnection_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_executeUpdate_81_bad extends CWE89_SQL_Injection__Property_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_prepareStatement_81_bad extends CWE89_SQL_Injection__Property_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__PropertiesFile_prepareStatement_81_bad extends CWE89_SQL_Injection__PropertiesFile_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_executeQuery_81_bad extends CWE89_SQL_Injection__URLConnection_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_execute_81_bad extends CWE89_SQL_Injection__Property_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__PropertiesFile_execute_81_bad extends CWE89_SQL_Injection__PropertiesFile_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_execute_81_bad extends CWE89_SQL_Injection__URLConnection_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_executeQuery_81_bad extends CWE89_SQL_Injection__Property_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_executeUpdate_81_bad extends CWE89_SQL_Injection__URLConnection_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_executeBatch_81_bad extends CWE89_SQL_Injection__URLConnection_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_execute_81_bad extends CWE89_SQL_Injection__listen_tcp_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_executeQuery_81_bad extends CWE89_SQL_Injection__listen_tcp_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_81_bad extends CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getParameter_Servlet_prepareStatement_81_bad extends CWE89_SQL_Injection__getParameter_Servlet_prepareStatement_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_executeBatch_81_bad extends CWE89_SQL_Injection__listen_tcp_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__PropertiesFile_executeBatch_81_bad extends CWE89_SQL_Injection__PropertiesFile_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getParameter_Servlet_execute_81_bad extends CWE89_SQL_Injection__getParameter_Servlet_execute_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getParameter_Servlet_executeUpdate_81_bad extends CWE89_SQL_Injection__getParameter_Servlet_executeUpdate_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_executeQuery_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__PropertiesFile_executeQuery_81_bad extends CWE89_SQL_Injection__PropertiesFile_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_81_bad extends CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_prepareStatement_81_bad extends CWE89_SQL_Injection__listen_tcp_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_prepareStatement_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_prepareStatement_81_bad extends CWE89_SQL_Injection__getQueryString_Servlet_prepareStatement_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_executeUpdate_81_bad extends CWE89_SQL_Injection__listen_tcp_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_executeUpdate_81_bad extends CWE89_SQL_Injection__getQueryString_Servlet_executeUpdate_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_executeUpdate_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__PropertiesFile_executeUpdate_81_bad extends CWE89_SQL_Injection__PropertiesFile_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_execute_81_bad.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_bad.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_execute_81_bad extends CWE89_SQL_Injection__getQueryString_Servlet_execute_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",CWE89
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE566_Authorization_Bypass_Through_SQL_Primary__Servlet_81_goodG2B.java
Label Definition File: CWE566_Authorization_Bypass_Through_SQL_Primary__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 566 Authorization Bypass through SQL primary
 * BadSource:  user id taken from url parameter
 * GoodSource: hardcoded user id
 * Sinks: writeConsole
 *    BadSink : user authorization not checked
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE566_Authorization_Bypass_Through_SQL_Primary;

public class CWE566_Authorization_Bypass_Through_SQL_Primary__Servlet_81_goodG2B extends CWE566_Authorization_Bypass_Through_SQL_Primary__Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dBConnection = IO.getDBConnection();
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int id = 0;
        try {
            id = Integer.parseInt(data);
        } catch (NumberFormatException nfx) {
            id = -1;
            /* Assuming this id does not exist */
        }
        try {
            preparedStatement = dBConnection.prepareStatement(""select * from invoices where uid=?"");
            preparedStatement.setInt(1, id);
            resultSet = preparedStatement.executeQuery();
            /* POTENTIAL FLAW: no check to see whether the user has privileges to view the data */
            IO.writeString(""bad() - result requested: "" + data + ""\n"");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error executing query"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Could not close ResultSet"", exceptSql);
            }
            try {
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Could not close PreparedStatement"", exceptSql);
            }
            try {
                if (dBConnection != null) {
                    dBConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Could not close Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__Property_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__Property_81_goodB2G extends CWE643_Xpath_Injection__Property_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__PropertiesFile_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__PropertiesFile_81_goodB2G extends CWE643_Xpath_Injection__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__connect_tcp_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__connect_tcp_81_goodB2G extends CWE643_Xpath_Injection__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__database_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__database_81_goodG2B extends CWE643_Xpath_Injection__database_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__getQueryString_Servlet_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__getQueryString_Servlet_81_goodB2G extends CWE643_Xpath_Injection__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__console_readLine_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__console_readLine_81_goodB2G extends CWE643_Xpath_Injection__console_readLine_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__getCookies_Servlet_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__getCookies_Servlet_81_goodB2G extends CWE643_Xpath_Injection__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__Environment_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__Environment_81_goodB2G extends CWE643_Xpath_Injection__Environment_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__getParameter_Servlet_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__getParameter_Servlet_81_goodB2G extends CWE643_Xpath_Injection__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__getQueryString_Servlet_81_goodG2B extends CWE643_Xpath_Injection__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__URLConnection_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__URLConnection_81_goodB2G extends CWE643_Xpath_Injection__URLConnection_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__getCookies_Servlet_81_goodG2B extends CWE643_Xpath_Injection__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__URLConnection_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__URLConnection_81_goodG2B extends CWE643_Xpath_Injection__URLConnection_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__console_readLine_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__console_readLine_81_goodG2B extends CWE643_Xpath_Injection__console_readLine_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__PropertiesFile_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__PropertiesFile_81_goodG2B extends CWE643_Xpath_Injection__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__File_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__File_81_goodB2G extends CWE643_Xpath_Injection__File_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__listen_tcp_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__listen_tcp_81_goodG2B extends CWE643_Xpath_Injection__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__File_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__File_81_goodG2B extends CWE643_Xpath_Injection__File_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__database_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__database_81_goodB2G extends CWE643_Xpath_Injection__database_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__getParameter_Servlet_81_goodG2B extends CWE643_Xpath_Injection__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__Property_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__Property_81_goodG2B extends CWE643_Xpath_Injection__Property_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__Environment_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__Environment_81_goodG2B extends CWE643_Xpath_Injection__Environment_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__listen_tcp_81_goodB2G.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__listen_tcp_81_goodB2G extends CWE643_Xpath_Injection__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            /* FIX: validate input using StringEscapeUtils */
            String username = StringEscapeUtils.escapeXml(tokens[0]);
            String password = StringEscapeUtils.escapeXml(tokens[1]);
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE643_Xpath_Injection__connect_tcp_81_goodG2B.java
Label Definition File: CWE643_Xpath_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 643 Xpath Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    GoodSink: validate input through StringEscapeUtils
 *    BadSink : user input is used without validate
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE643_Xpath_Injection;

public class CWE643_Xpath_Injection__connect_tcp_81_goodG2B extends CWE643_Xpath_Injection__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        String xmlFile = null;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            xmlFile = ""\\src\\testcases\\CWE643_Xpath Injection\\CWE643_Xpath_Injection__Helper.xml"";
        } else {
            /* running on non-Windows */
            xmlFile = ""./src/testcases/CWE643_Xpath Injection/CWE643_Xpath_Injection__Helper.xml"";
        }
        if (data != null) {
            /* assume username||password as source */
            String[] tokens = data.split(""||"");
            if (tokens.length < 2) {
                return;
            }
            String username = tokens[0];
            String password = tokens[1];
            /* build xpath */
            XPath xPath = XPathFactory.newInstance().newXPath();
            InputSource inputXml = new InputSource(xmlFile);
            /* INCIDENTAL: CWE180 Incorrect Behavior Order: Validate Before Canonicalize
             *     The user input should be canonicalized before validation. */
            /* POTENTIAL FLAW: user input is used without validate */
            String query = ""//users/user[name/text()='"" + username + ""' and pass/text()='"" + password + ""']"" + ""/secret/text()"";
            String secret = (String) xPath.evaluate(query, inputXml, XPathConstants.STRING);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_getParameter_Servlet_81_goodG2B extends CWE601_Open_Redirect__Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_File_81_goodG2B.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_File_81_goodG2B extends CWE601_Open_Redirect__Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_PropertiesFile_81_goodG2B.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_PropertiesFile_81_goodG2B extends CWE601_Open_Redirect__Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_connect_tcp_81_goodG2B.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_connect_tcp_81_goodG2B extends CWE601_Open_Redirect__Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_database_81_goodG2B.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_database_81_goodG2B extends CWE601_Open_Redirect__Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_URLConnection_81_goodG2B.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_URLConnection_81_goodG2B extends CWE601_Open_Redirect__Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_listen_tcp_81_goodG2B.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_listen_tcp_81_goodG2B extends CWE601_Open_Redirect__Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_getQueryString_Servlet_81_goodG2B extends CWE601_Open_Redirect__Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE601_Open_Redirect__Servlet_getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE601_Open_Redirect__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 601 Open Redirect
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : place redirect string directly into redirect api call
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE601_Open_Redirect;

public class CWE601_Open_Redirect__Servlet_getCookies_Servlet_81_goodG2B extends CWE601_Open_Redirect__Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* This prevents \r\n (and other chars) and should prevent incidentals such
             * as HTTP Response Splitting and HTTP Header Injection.
             */
            URI uri;
            try {
                uri = new URI(data);
            } catch (URISyntaxException exceptURISyntax) {
                response.getWriter().write(""Invalid redirect URL"");
                return;
            }
            /* POTENTIAL FLAW: redirect is sent verbatim; escape the string to prevent ancillary issues like XSS, Response splitting etc */
            response.sendRedirect(data);
            return;
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_getParameter_Servlet_81_goodG2B extends CWE81_XSS_Error_Message__Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_File_81_goodG2B.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_File_81_goodG2B extends CWE81_XSS_Error_Message__Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_getQueryString_Servlet_81_goodG2B extends CWE81_XSS_Error_Message__Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_URLConnection_81_goodG2B.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_URLConnection_81_goodG2B extends CWE81_XSS_Error_Message__Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_getCookies_Servlet_81_goodG2B extends CWE81_XSS_Error_Message__Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_connect_tcp_81_goodG2B.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_connect_tcp_81_goodG2B extends CWE81_XSS_Error_Message__Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_database_81_goodG2B.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_database_81_goodG2B extends CWE81_XSS_Error_Message__Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_PropertiesFile_81_goodG2B.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_PropertiesFile_81_goodG2B extends CWE81_XSS_Error_Message__Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE81_XSS_Error_Message__Servlet_listen_tcp_81_goodG2B.java
Label Definition File: CWE81_XSS_Error_Message__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 81 Cross Site Scripting (XSS) in Error Message
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: sendErrorServlet
 *    BadSink : XSS in sendError
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE81_XSS_Error_Message;

public class CWE81_XSS_Error_Message__Servlet_listen_tcp_81_goodG2B extends CWE81_XSS_Error_Message__Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: script code (e.g. id=<script>alert('xss')</script>) is sent to the client;
            * The built-in J2EE server automatically does some HTML entity encoding.
            * Therefore, to test this, change response.sendError to response.getWriter().println and remove the 404,
            */
            response.sendError(404, ""<br>bad() - Parameter name has value "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__File_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__getCookies_Servlet_prepareStatement_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getParameter_Servlet_executeBatch_81_goodB2G extends CWE89_SQL_Injection__getParameter_Servlet_executeBatch_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__Environment_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_execute_81_goodG2B extends CWE89_SQL_Injection__Environment_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getParameter_Servlet_executeQuery_81_goodB2G extends CWE89_SQL_Injection__getParameter_Servlet_executeQuery_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_executeQuery_81_goodG2B extends CWE89_SQL_Injection__getCookies_Servlet_executeQuery_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_execute_81_goodB2G extends CWE89_SQL_Injection__File_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__File_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__File_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__Environment_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_execute_81_goodB2G extends CWE89_SQL_Injection__Environment_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__getCookies_Servlet_executeUpdate_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getParameter_Servlet_executeBatch_81_goodG2B extends CWE89_SQL_Injection__getParameter_Servlet_executeBatch_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_executeQuery_81_goodG2B extends CWE89_SQL_Injection__Environment_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__getCookies_Servlet_prepareStatement_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_executeBatch_81_goodG2B extends CWE89_SQL_Injection__File_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__File_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__Environment_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_executeQuery_81_goodG2B extends CWE89_SQL_Injection__File_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_executeQuery_81_goodB2G extends CWE89_SQL_Injection__getCookies_Servlet_executeQuery_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__Environment_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_executeBatch_81_goodB2G extends CWE89_SQL_Injection__getCookies_Servlet_executeBatch_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getParameter_Servlet_executeQuery_81_goodG2B extends CWE89_SQL_Injection__getParameter_Servlet_executeQuery_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_executeBatch_81_goodB2G extends CWE89_SQL_Injection__File_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__Environment_executeQuery_81_goodB2G extends CWE89_SQL_Injection__Environment_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__getCookies_Servlet_executeUpdate_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_executeQuery_81_goodB2G extends CWE89_SQL_Injection__File_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__File_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__File_execute_81_goodG2B extends CWE89_SQL_Injection__File_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_execute_81_goodG2B extends CWE89_SQL_Injection__getCookies_Servlet_execute_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_executeBatch_81_goodG2B extends CWE89_SQL_Injection__getCookies_Servlet_executeBatch_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getCookies_Servlet_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s02;

public class CWE89_SQL_Injection__getCookies_Servlet_execute_81_goodB2G extends CWE89_SQL_Injection__getCookies_Servlet_execute_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__console_readLine_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__console_readLine_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_execute_81_goodG2B extends CWE89_SQL_Injection__console_readLine_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__console_readLine_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__connect_tcp_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_executeQuery_81_goodG2B extends CWE89_SQL_Injection__connect_tcp_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_executeBatch_81_goodG2B extends CWE89_SQL_Injection__connect_tcp_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_executeQuery_81_goodB2G extends CWE89_SQL_Injection__connect_tcp_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_executeQuery_81_goodB2G extends CWE89_SQL_Injection__console_readLine_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_execute_81_goodB2G extends CWE89_SQL_Injection__connect_tcp_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_executeBatch_81_goodB2G extends CWE89_SQL_Injection__console_readLine_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_execute_81_goodG2B extends CWE89_SQL_Injection__database_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__Environment_executeBatch_81_goodG2B extends CWE89_SQL_Injection__Environment_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_execute_81_goodB2G extends CWE89_SQL_Injection__database_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_executeBatch_81_goodB2G extends CWE89_SQL_Injection__connect_tcp_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__database_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_executeBatch_81_goodG2B extends CWE89_SQL_Injection__database_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_executeBatch_81_goodB2G extends CWE89_SQL_Injection__database_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_executeQuery_81_goodG2B extends CWE89_SQL_Injection__console_readLine_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__connect_tcp_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__console_readLine_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__connect_tcp_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Environment_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__Environment_executeBatch_81_goodB2G extends CWE89_SQL_Injection__Environment_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_executeQuery_81_goodB2G extends CWE89_SQL_Injection__database_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__database_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__database_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_execute_81_goodG2B extends CWE89_SQL_Injection__connect_tcp_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_executeQuery_81_goodG2B extends CWE89_SQL_Injection__database_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_executeBatch_81_goodG2B extends CWE89_SQL_Injection__console_readLine_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__database_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__database_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__database_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__console_readLine_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__console_readLine_execute_81_goodB2G extends CWE89_SQL_Injection__console_readLine_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__connect_tcp_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s01;

public class CWE89_SQL_Injection__connect_tcp_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__connect_tcp_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__Property_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_executeQuery_81_goodB2G extends CWE89_SQL_Injection__URLConnection_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__URLConnection_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_executeQuery_81_goodG2B extends CWE89_SQL_Injection__URLConnection_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__Property_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_executeBatch_81_goodB2G extends CWE89_SQL_Injection__URLConnection_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_executeBatch_81_goodB2G extends CWE89_SQL_Injection__Property_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_executeBatch_81_goodG2B extends CWE89_SQL_Injection__URLConnection_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_executeQuery_81_goodG2B extends CWE89_SQL_Injection__Property_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__URLConnection_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__PropertiesFile_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__PropertiesFile_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__URLConnection_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_execute_81_goodB2G extends CWE89_SQL_Injection__Property_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_executeBatch_81_goodG2B extends CWE89_SQL_Injection__Property_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__Property_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_execute_81_goodG2B extends CWE89_SQL_Injection__URLConnection_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__PropertiesFile_execute_81_goodB2G extends CWE89_SQL_Injection__PropertiesFile_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__PropertiesFile_execute_81_goodG2B extends CWE89_SQL_Injection__PropertiesFile_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__PropertiesFile_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__PropertiesFile_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_execute_81_goodG2B extends CWE89_SQL_Injection__Property_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_executeQuery_81_goodB2G extends CWE89_SQL_Injection__Property_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__Property_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__Property_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__Property_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__URLConnection_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__URLConnection_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s04;

public class CWE89_SQL_Injection__URLConnection_execute_81_goodB2G extends CWE89_SQL_Injection__URLConnection_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_81_goodB2G extends CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_execute_81_goodB2G extends CWE89_SQL_Injection__getQueryString_Servlet_execute_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getParameter_Servlet_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__getParameter_Servlet_prepareStatement_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__PropertiesFile_executeBatch_81_goodG2B extends CWE89_SQL_Injection__PropertiesFile_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__PropertiesFile_executeQuery_81_goodG2B extends CWE89_SQL_Injection__PropertiesFile_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__listen_tcp_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__listen_tcp_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_executeBatch_81_goodG2B extends CWE89_SQL_Injection__listen_tcp_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__getQueryString_Servlet_executeUpdate_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__listen_tcp_prepareStatement_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__PropertiesFile_executeQuery_81_goodB2G extends CWE89_SQL_Injection__PropertiesFile_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_81_goodG2B extends CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            Statement sqlStatement = null;
            try {
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.createStatement();
                for (int i = 0; i < names.length; i++) {
                    /* POTENTIAL FLAW: data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection */
                    sqlStatement.addBatch(""update users set hitcount=hitcount+1 where name='"" + names[i] + ""'"");
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Statament"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__PropertiesFile_executeBatch_81_goodB2G extends CWE89_SQL_Injection__PropertiesFile_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_81_goodG2B extends CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__PropertiesFile_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__PropertiesFile_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__PropertiesFile_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__PropertiesFile_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__PropertiesFile_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_81_goodB2G extends CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getParameter_Servlet_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__getParameter_Servlet_executeUpdate_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getParameter_Servlet_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__getParameter_Servlet_prepareStatement_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_executeUpdate_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getParameter_Servlet_executeUpdate_81_goodB2G extends CWE89_SQL_Injection__getParameter_Servlet_executeUpdate_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and executeUpdate (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            int rowCount = sqlStatement.executeUpdate();
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_prepareStatement_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_prepareStatement_81_goodB2G extends CWE89_SQL_Injection__getQueryString_Servlet_prepareStatement_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_executeQuery_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_executeQuery_81_goodB2G extends CWE89_SQL_Injection__listen_tcp_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            /* FIX: Use prepared statement and executeQuery (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""select * from users where name=?"");
            sqlStatement.setString(1, data);
            resultSet = sqlStatement.executeQuery();
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__listen_tcp_executeUpdate_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_executeBatch_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeBatch
 *    GoodSink: Use prepared statement and executeBatch (properly)
 *    BadSink : data concatenated into SQL statement used in executeBatch(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_executeBatch_81_goodB2G extends CWE89_SQL_Injection__listen_tcp_executeBatch_81_base {

    public void action(String data) throws Throwable {
        if (data != null) {
            String[] names = data.split(""-"");
            int successCount = 0;
            Connection dbConnection = null;
            PreparedStatement sqlStatement = null;
            try {
                /* FIX: Use prepared statement and executeBatch (properly) */
                dbConnection = IO.getDBConnection();
                sqlStatement = dbConnection.prepareStatement(""update users set hitcount=hitcount+1 where name=?"");
                for (int i = 0; i < names.length; i++) {
                    sqlStatement.setString(1, names[i]);
                    sqlStatement.addBatch();
                }
                int[] resultsArray = sqlStatement.executeBatch();
                for (int i = 0; i < names.length; i++) {
                    if (resultsArray[i] > 0) {
                        successCount++;
                    }
                }
                IO.writeLine(""Succeeded in "" + successCount + "" out of "" + names.length + "" queries."");
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
            } finally {
                try {
                    if (sqlStatement != null) {
                        sqlStatement.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
                }
                try {
                    if (dbConnection != null) {
                        dbConnection.close();
                    }
                } catch (SQLException exceptSql) {
                    IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getParameter_Servlet_execute_81_goodG2B extends CWE89_SQL_Injection__getParameter_Servlet_execute_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_executeUpdate_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: executeUpdate
 *    GoodSink: Use prepared statement and executeUpdate (properly)
 *    BadSink : data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_executeUpdate_81_goodG2B extends CWE89_SQL_Injection__getQueryString_Servlet_executeUpdate_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeUpdate(), which could result in SQL Injection */
            int rowCount = sqlStatement.executeUpdate(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            IO.writeLine(""Updated "" + rowCount + "" rows successfully."");
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_execute_81_goodG2B extends CWE89_SQL_Injection__getQueryString_Servlet_execute_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getParameter_Servlet_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getParameter_Servlet_execute_81_goodB2G extends CWE89_SQL_Injection__getParameter_Servlet_execute_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_executeQuery_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: executeQuery
 *    GoodSink: Use prepared statement and executeQuery (properly)
 *    BadSink : data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_executeQuery_81_goodG2B extends CWE89_SQL_Injection__listen_tcp_executeQuery_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        ResultSet resultSet = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in executeQuery(), which could result in SQL Injection */
            resultSet = sqlStatement.executeQuery(""select * from users where name='"" + data + ""'"");
            IO.writeLine(resultSet.getRow());
            /* Use ResultSet in some way */
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing ResultSet"", exceptSql);
            }
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_execute_81_goodB2G.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_execute_81_goodB2G extends CWE89_SQL_Injection__listen_tcp_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* FIX: Use prepared statement and execute (properly) */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name=?"");
            sqlStatement.setString(1, data);
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__getQueryString_Servlet_prepareStatement_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: prepareStatement
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__getQueryString_Servlet_prepareStatement_81_goodG2B extends CWE89_SQL_Injection__getQueryString_Servlet_prepareStatement_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        PreparedStatement sqlStatement = null;
        try {
            /* POTENTIAL FLAW: data concatenated into SQL statement used in prepareStatement() call, which could result in SQL Injection */
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.prepareStatement(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            Boolean result = sqlStatement.execute();
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing PreparedStatement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE89_SQL_Injection__listen_tcp_execute_81_goodG2B.java
Label Definition File: CWE89_SQL_Injection.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 89 SQL Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: execute
 *    GoodSink: Use prepared statement and execute (properly)
 *    BadSink : data concatenated into SQL statement used in execute(), which could result in SQL Injection
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE89_SQL_Injection.s03;

public class CWE89_SQL_Injection__listen_tcp_execute_81_goodG2B extends CWE89_SQL_Injection__listen_tcp_execute_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        Statement sqlStatement = null;
        try {
            dbConnection = IO.getDBConnection();
            sqlStatement = dbConnection.createStatement();
            /* POTENTIAL FLAW: data concatenated into SQL statement used in execute(), which could result in SQL Injection */
            Boolean result = sqlStatement.execute(""insert into users (status) values ('updated') where name='"" + data + ""'"");
            if (result) {
                IO.writeLine(""Name, "" + data + "", updated successfully"");
            } else {
                IO.writeLine(""Unable to update records for user: "" + data);
            }
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (sqlStatement != null) {
                    sqlStatement.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Statement"", exceptSql);
            }
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_URLConnection_81_goodG2B.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s02;

public class CWE80_XSS__Servlet_URLConnection_81_goodG2B extends CWE80_XSS__Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_PropertiesFile_81_goodG2B.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s02;

public class CWE80_XSS__Servlet_PropertiesFile_81_goodG2B extends CWE80_XSS__Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_getParameter_Servlet_81_goodG2B extends CWE80_XSS__CWE182_Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_listen_tcp_81_goodG2B.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_listen_tcp_81_goodG2B extends CWE80_XSS__CWE182_Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_getQueryString_Servlet_81_goodG2B extends CWE80_XSS__CWE182_Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_connect_tcp_81_goodG2B.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_connect_tcp_81_goodG2B extends CWE80_XSS__Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_getCookies_Servlet_81_goodG2B extends CWE80_XSS__Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_PropertiesFile_81_goodG2B.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_PropertiesFile_81_goodG2B extends CWE80_XSS__CWE182_Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_listen_tcp_81_goodG2B.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_listen_tcp_81_goodG2B extends CWE80_XSS__Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_connect_tcp_81_goodG2B.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_connect_tcp_81_goodG2B extends CWE80_XSS__CWE182_Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_File_81_goodG2B.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_File_81_goodG2B extends CWE80_XSS__CWE182_Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_getCookies_Servlet_81_goodG2B extends CWE80_XSS__CWE182_Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_database_81_goodG2B.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_database_81_goodG2B extends CWE80_XSS__CWE182_Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_File_81_goodG2B.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_File_81_goodG2B extends CWE80_XSS__Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_database_81_goodG2B.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_database_81_goodG2B extends CWE80_XSS__Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__CWE182_Servlet_URLConnection_81_goodG2B.java
Label Definition File: CWE80_XSS__CWE182_Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__CWE182_Servlet_URLConnection_81_goodG2B extends CWE80_XSS__CWE182_Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */
            response.getWriter().println(""<br>bad(): data = "" + data.replaceAll(""(<script>)"", """"));
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_getQueryString_Servlet_81_goodG2B extends CWE80_XSS__Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE80_XSS__Servlet_getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE80_XSS__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 80 Cross Site Scripting (XSS)
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Display of data in web page without any encoding or validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE80_XSS.s01;

public class CWE80_XSS__Servlet_getParameter_Servlet_81_goodG2B extends CWE80_XSS__Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Display of data in web page without any encoding or validation */
            response.getWriter().println(""<br>bad(): data = "" + data);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__getCookies_Servlet_81_goodG2B extends CWE78_OS_Command_Injection__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__database_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__database_81_goodG2B extends CWE78_OS_Command_Injection__database_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__console_readLine_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__console_readLine_81_goodG2B extends CWE78_OS_Command_Injection__console_readLine_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__listen_tcp_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__listen_tcp_81_goodG2B extends CWE78_OS_Command_Injection__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__Property_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__Property_81_goodG2B extends CWE78_OS_Command_Injection__Property_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__getParameter_Servlet_81_goodG2B extends CWE78_OS_Command_Injection__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__connect_tcp_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__connect_tcp_81_goodG2B extends CWE78_OS_Command_Injection__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__Environment_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__Environment_81_goodG2B extends CWE78_OS_Command_Injection__Environment_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__URLConnection_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__URLConnection_81_goodG2B extends CWE78_OS_Command_Injection__URLConnection_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__PropertiesFile_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__PropertiesFile_81_goodG2B extends CWE78_OS_Command_Injection__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__getQueryString_Servlet_81_goodG2B extends CWE78_OS_Command_Injection__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE78_OS_Command_Injection__File_81_goodG2B.java
Label Definition File: CWE78_OS_Command_Injection.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: exec
 *    BadSink : dynamic command execution with Runtime.getRuntime().exec()
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE78_OS_Command_Injection;

public class CWE78_OS_Command_Injection__File_81_goodG2B extends CWE78_OS_Command_Injection__File_81_base {

    public void action(String data) throws Throwable {
        String osCommand;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            osCommand = ""c:\\WINDOWS\\SYSTEM32\\cmd.exe /c dir "";
        } else {
            /* running on non-Windows */
            osCommand = ""/bin/ls "";
        }
        /* POTENTIAL FLAW: command injection */
        Process process = Runtime.getRuntime().exec(osCommand + data);
        process.waitFor();
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_getQueryString_Servlet_81_goodG2B extends CWE83_XSS_Attribute__Servlet_getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_PropertiesFile_81_goodG2B.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_PropertiesFile_81_goodG2B extends CWE83_XSS_Attribute__Servlet_PropertiesFile_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_getParameter_Servlet_81_goodG2B extends CWE83_XSS_Attribute__Servlet_getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_File_81_goodG2B.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_File_81_goodG2B extends CWE83_XSS_Attribute__Servlet_File_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_listen_tcp_81_goodG2B.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_listen_tcp_81_goodG2B extends CWE83_XSS_Attribute__Servlet_listen_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_URLConnection_81_goodG2B.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_URLConnection_81_goodG2B extends CWE83_XSS_Attribute__Servlet_URLConnection_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_connect_tcp_81_goodG2B.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_connect_tcp_81_goodG2B extends CWE83_XSS_Attribute__Servlet_connect_tcp_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_database_81_goodG2B.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_database_81_goodG2B extends CWE83_XSS_Attribute__Servlet_database_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE83_XSS_Attribute__Servlet_getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE83_XSS_Attribute__Servlet.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 83 Cross Site Scripting (XSS) in attributes; Examples(replace QUOTE with an actual double quote): ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEalert(1) and ?img_loc=http://www.google.comQUOTE%20onerror=QUOTEjavascript:alert(1)
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: printlnServlet
 *    BadSink : XSS in img src attribute
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE83_XSS_Attribute;

public class CWE83_XSS_Attribute__Servlet_getCookies_Servlet_81_goodG2B extends CWE83_XSS_Attribute__Servlet_getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        if (data != null) {
            /* POTENTIAL FLAW: Input is not verified/sanitized before use in an image tag */
            response.getWriter().println(""<br>bad() - <img src=\"""" + data + ""\"">"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Class_String_81_goodB2G.java
Label Definition File: CWE690_NULL_Deref_From_Return__Class.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource:  Use a custom method which may return null
 * GoodSource: Use a custom method that never returns null
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Class_String_81_goodB2G extends CWE690_NULL_Deref_From_Return__Class_String_81_base {

    public void action(String data) throws Throwable {
        /* FIX: explicit check for null */
        if (data != null) {
            String stringTrimmed = data.trim();
            IO.writeLine(stringTrimmed);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__getParameter_Servlet_trim_81_goodG2B.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: getParameter_Servlet Set data to return of getParameter_Servlet
 * GoodSource: Set data to fixed, non-null String
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__getParameter_Servlet_trim_81_goodG2B extends CWE690_NULL_Deref_From_Return__getParameter_Servlet_trim_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.trim();
        IO.writeLine(stringTrimmed);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Properties_getProperty_trim_81_goodB2G.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: Properties_getProperty Set data to return of Properties.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Properties_getProperty_trim_81_goodB2G extends CWE690_NULL_Deref_From_Return__Properties_getProperty_trim_81_base {

    public void action(String data) throws Throwable {
        /* FIX: explicit check for null */
        if (data != null) {
            String stringTrimmed = data.trim();
            IO.writeLine(stringTrimmed);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__getParameter_Servlet_equals_81_goodB2G.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: getParameter_Servlet Set data to return of getParameter_Servlet
 * GoodSource: Set data to fixed, non-null String
 * Sinks: equals
 *    GoodSink: Call equals() on string literal (that is not null)
 *    BadSink : Call equals() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__getParameter_Servlet_equals_81_goodB2G extends CWE690_NULL_Deref_From_Return__getParameter_Servlet_equals_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* FIX: call equals() on string literal (that is not null) */
        if (""CWE690"".equals(data)) {
            IO.writeLine(""data is CWE690"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__System_getProperty_trim_81_goodB2G.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: System_getProperty Set data to return of System.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__System_getProperty_trim_81_goodB2G extends CWE690_NULL_Deref_From_Return__System_getProperty_trim_81_base {

    public void action(String data) throws Throwable {
        /* FIX: explicit check for null */
        if (data != null) {
            String stringTrimmed = data.trim();
            IO.writeLine(stringTrimmed);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__System_getProperty_trim_81_goodG2B.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: System_getProperty Set data to return of System.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__System_getProperty_trim_81_goodG2B extends CWE690_NULL_Deref_From_Return__System_getProperty_trim_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.trim();
        IO.writeLine(stringTrimmed);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Class_StringBuilder_81_goodG2B.java
Label Definition File: CWE690_NULL_Deref_From_Return__Class.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource:  Use a custom method which may return null
 * GoodSource: Use a custom method that never returns null
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Class_StringBuilder_81_goodG2B extends CWE690_NULL_Deref_From_Return__Class_StringBuilder_81_base {

    public void action(StringBuilder data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.toString().trim();
        IO.writeLine(stringTrimmed);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__System_getProperty_equals_81_goodB2G.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: System_getProperty Set data to return of System.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: equals
 *    GoodSink: Call equals() on string literal (that is not null)
 *    BadSink : Call equals() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__System_getProperty_equals_81_goodB2G extends CWE690_NULL_Deref_From_Return__System_getProperty_equals_81_base {

    public void action(String data) throws Throwable {
        /* FIX: call equals() on string literal (that is not null) */
        if (""CWE690"".equals(data)) {
            IO.writeLine(""data is CWE690"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Properties_getProperty_equals_81_goodG2B.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: Properties_getProperty Set data to return of Properties.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: equals
 *    GoodSink: Call equals() on string literal (that is not null)
 *    BadSink : Call equals() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Properties_getProperty_equals_81_goodG2B extends CWE690_NULL_Deref_From_Return__Properties_getProperty_equals_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        if (data.equals(""CWE690"")) {
            IO.writeLine(""data is CWE690"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Properties_getProperty_equals_81_goodB2G.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: Properties_getProperty Set data to return of Properties.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: equals
 *    GoodSink: Call equals() on string literal (that is not null)
 *    BadSink : Call equals() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Properties_getProperty_equals_81_goodB2G extends CWE690_NULL_Deref_From_Return__Properties_getProperty_equals_81_base {

    public void action(String data) throws Throwable {
        /* FIX: call equals() on string literal (that is not null) */
        if (""CWE690"".equals(data)) {
            IO.writeLine(""data is CWE690"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Class_StringBuilder_81_goodB2G.java
Label Definition File: CWE690_NULL_Deref_From_Return__Class.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource:  Use a custom method which may return null
 * GoodSource: Use a custom method that never returns null
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Class_StringBuilder_81_goodB2G extends CWE690_NULL_Deref_From_Return__Class_StringBuilder_81_base {

    public void action(StringBuilder data) throws Throwable {
        /* FIX: explicit check for null */
        if (data != null) {
            String stringTrimmed = data.toString().trim();
            IO.writeLine(stringTrimmed);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__getParameter_Servlet_equals_81_goodG2B.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: getParameter_Servlet Set data to return of getParameter_Servlet
 * GoodSource: Set data to fixed, non-null String
 * Sinks: equals
 *    GoodSink: Call equals() on string literal (that is not null)
 *    BadSink : Call equals() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__getParameter_Servlet_equals_81_goodG2B extends CWE690_NULL_Deref_From_Return__getParameter_Servlet_equals_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        if (data.equals(""CWE690"")) {
            IO.writeLine(""data is CWE690"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__System_getProperty_equals_81_goodG2B.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: System_getProperty Set data to return of System.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: equals
 *    GoodSink: Call equals() on string literal (that is not null)
 *    BadSink : Call equals() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__System_getProperty_equals_81_goodG2B extends CWE690_NULL_Deref_From_Return__System_getProperty_equals_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        if (data.equals(""CWE690"")) {
            IO.writeLine(""data is CWE690"");
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Class_String_81_goodG2B.java
Label Definition File: CWE690_NULL_Deref_From_Return__Class.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource:  Use a custom method which may return null
 * GoodSource: Use a custom method that never returns null
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Class_String_81_goodG2B extends CWE690_NULL_Deref_From_Return__Class_String_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.trim();
        IO.writeLine(stringTrimmed);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__getParameter_Servlet_trim_81_goodB2G.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodB2G.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: getParameter_Servlet Set data to return of getParameter_Servlet
 * GoodSource: Set data to fixed, non-null String
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__getParameter_Servlet_trim_81_goodB2G extends CWE690_NULL_Deref_From_Return__getParameter_Servlet_trim_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* FIX: explicit check for null */
        if (data != null) {
            String stringTrimmed = data.trim();
            IO.writeLine(stringTrimmed);
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE690_NULL_Deref_From_Return__Properties_getProperty_trim_81_goodG2B.java
Label Definition File: CWE690_NULL_Deref_From_Return.label.xml
Template File: sources-sinks-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 690 Unchecked return value is null, leading to a null pointer dereference.
 * BadSource: Properties_getProperty Set data to return of Properties.getProperty
 * GoodSource: Set data to fixed, non-null String
 * Sinks: trim
 *    GoodSink: Check data for null before calling trim()
 *    BadSink : Call trim() on possibly null object
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE690_NULL_Deref_From_Return;

public class CWE690_NULL_Deref_From_Return__Properties_getProperty_trim_81_goodG2B extends CWE690_NULL_Deref_From_Return__Properties_getProperty_trim_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: data could be null */
        String stringTrimmed = data.trim();
        IO.writeLine(stringTrimmed);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__getQueryString_Servlet_81_goodG2B extends CWE23_Relative_Path_Traversal__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__Environment_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__Environment_81_goodG2B extends CWE23_Relative_Path_Traversal__Environment_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__console_readLine_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__console_readLine_81_goodG2B extends CWE23_Relative_Path_Traversal__console_readLine_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__connect_tcp_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__connect_tcp_81_goodG2B extends CWE23_Relative_Path_Traversal__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__URLConnection_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__URLConnection_81_goodG2B extends CWE23_Relative_Path_Traversal__URLConnection_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__listen_tcp_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__listen_tcp_81_goodG2B extends CWE23_Relative_Path_Traversal__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__File_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__File_81_goodG2B extends CWE23_Relative_Path_Traversal__File_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__Property_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__Property_81_goodG2B extends CWE23_Relative_Path_Traversal__Property_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__PropertiesFile_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__PropertiesFile_81_goodG2B extends CWE23_Relative_Path_Traversal__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__database_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__database_81_goodG2B extends CWE23_Relative_Path_Traversal__database_81_base {

    public void action(String data) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__getCookies_Servlet_81_goodG2B extends CWE23_Relative_Path_Traversal__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE23_Relative_Path_Traversal__getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE23_Relative_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 23 Relative Path Traversal
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : no validation
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE23_Relative_Path_Traversal;

public class CWE23_Relative_Path_Traversal__getParameter_Servlet_81_goodG2B extends CWE23_Relative_Path_Traversal__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        String root;
        if (System.getProperty(""os.name"").toLowerCase().indexOf(""win"") >= 0) {
            /* running on Windows */
            root = ""C:\\uploads\\"";
        } else {
            /* running on non-Windows */
            root = ""/home/user/uploads/"";
        }
        if (data != null) {
            /* POTENTIAL FLAW: no validation of concatenated value */
            File file = new File(root + data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__getQueryString_Servlet_81_goodG2B extends CWE36_Absolute_Path_Traversal__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__File_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__File_81_goodG2B extends CWE36_Absolute_Path_Traversal__File_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__PropertiesFile_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__PropertiesFile_81_goodG2B extends CWE36_Absolute_Path_Traversal__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__connect_tcp_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__connect_tcp_81_goodG2B extends CWE36_Absolute_Path_Traversal__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__URLConnection_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__URLConnection_81_goodG2B extends CWE36_Absolute_Path_Traversal__URLConnection_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__getParameter_Servlet_81_goodG2B extends CWE36_Absolute_Path_Traversal__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__listen_tcp_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__listen_tcp_81_goodG2B extends CWE36_Absolute_Path_Traversal__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__database_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__database_81_goodG2B extends CWE36_Absolute_Path_Traversal__database_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__getCookies_Servlet_81_goodG2B extends CWE36_Absolute_Path_Traversal__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__console_readLine_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__console_readLine_81_goodG2B extends CWE36_Absolute_Path_Traversal__console_readLine_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__Property_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__Property_81_goodG2B extends CWE36_Absolute_Path_Traversal__Property_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE36_Absolute_Path_Traversal__Environment_81_goodG2B.java
Label Definition File: CWE36_Absolute_Path_Traversal.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 36 Absolute Path Traversal
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks: readFile
 *    BadSink : read line from file from disk
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE36_Absolute_Path_Traversal;

public class CWE36_Absolute_Path_Traversal__Environment_81_goodG2B extends CWE36_Absolute_Path_Traversal__Environment_81_base {

    public void action(String data) throws Throwable {
        /* POTENTIAL FLAW: unvalidated or sandboxed value */
        if (data != null) {
            File file = new File(data);
            FileInputStream streamFileInputSink = null;
            InputStreamReader readerInputStreamSink = null;
            BufferedReader readerBufferdSink = null;
            if (file.exists() && file.isFile()) {
                try {
                    streamFileInputSink = new FileInputStream(file);
                    readerInputStreamSink = new InputStreamReader(streamFileInputSink, ""UTF-8"");
                    readerBufferdSink = new BufferedReader(readerInputStreamSink);
                    IO.writeLine(readerBufferdSink.readLine());
                } catch (IOException exceptIO) {
                    IO.logger.log(Level.WARNING, ""Error with stream reading"", exceptIO);
                } finally {
                    /* Close stream reading objects */
                    try {
                        if (readerBufferdSink != null) {
                            readerBufferdSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing BufferedReader"", exceptIO);
                    }
                    try {
                        if (readerInputStreamSink != null) {
                            readerInputStreamSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing InputStreamReader"", exceptIO);
                    }
                    try {
                        if (streamFileInputSink != null) {
                            streamFileInputSink.close();
                        }
                    } catch (IOException exceptIO) {
                        IO.logger.log(Level.WARNING, ""Error closing FileInputStream"", exceptIO);
                    }
                }
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashMap_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashMap_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__max_value_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: max_value Set data to a hardcoded value of Integer.MAX_VALUE
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__max_value_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__max_value_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__max_value_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: max_value Set data to a hardcoded value of Integer.MAX_VALUE
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__max_value_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__max_value_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_ArrayList_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashMap_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashSet_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__listen_tcp_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__listen_tcp_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__listen_tcp_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_ArrayList_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__listen_tcp_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__getParameter_Servlet_HashSet_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__max_value_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: max_value Set data to a hardcoded value of Integer.MAX_VALUE
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__max_value_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__max_value_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s02;

public class CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_HashSet_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__console_readLine_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: console_readLine Read data from the console using readLine
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__console_readLine_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__console_readLine_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: console_readLine Read data from the console using readLine
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Environment_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__Environment_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__Environment_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__File_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__File_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__File_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__connect_tcp_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__connect_tcp_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__connect_tcp_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__database_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__database_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__database_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Environment_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__Environment_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__Environment_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__database_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__database_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__database_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__getCookies_Servlet_ArrayList_81_base {

    public void action(int data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__File_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__File_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__File_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__File_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__File_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__File_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__connect_tcp_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: console_readLine Read data from the console using readLine
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__console_readLine_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Environment_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__Environment_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__Environment_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__database_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s01;

public class CWE789_Uncontrolled_Mem_Alloc__database_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__database_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Property_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__Property_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__Property_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__random_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: random Set data to a random value
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__random_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__random_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__random_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: random Set data to a random value
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__random_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__random_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Property_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__Property_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__Property_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__URLConnection_ArrayList_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: ArrayList
 *    BadSink : Create an ArrayList using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__URLConnection_ArrayList_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__URLConnection_ArrayList_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create an ArrayList using data as the initial size.  data may be very large, creating memory issues */
        ArrayList intArrayList = new ArrayList(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashSet_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashSet
 *    BadSink : Create a HashSet using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashSet_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__PropertiesFile_HashSet_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  data may be very large, creating memory issues */
        HashSet intHashSet = new HashSet(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__random_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: random Set data to a random value
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__random_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__random_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__Property_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__Property_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__Property_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashMap_81_goodG2B.java
Label Definition File: CWE789_Uncontrolled_Mem_Alloc.int.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded non-zero, non-min, non-max, even number
 * Sinks: HashMap
 *    BadSink : Create a HashMap using data as the initial size
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE789_Uncontrolled_Mem_Alloc.s03;

public class CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashMap_81_goodG2B extends CWE789_Uncontrolled_Mem_Alloc__URLConnection_HashMap_81_base {

    public void action(int data) throws Throwable {
        /* POTENTIAL FLAW: Create a HashMap using data as the initial size.  data may be very large, creating memory issues */
        HashMap intHashMap = new HashMap(data);
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__getCookies_Servlet_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: getCookies_Servlet Read data from the first cookie using getCookies()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__getCookies_Servlet_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__getCookies_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__File_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: File Read data from file (named c:\data.txt)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__File_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__File_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__listen_tcp_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: listen_tcp Read data using a listening tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__listen_tcp_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__listen_tcp_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__console_readLine_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: console_readLine Read data from the console using readLine()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__console_readLine_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__console_readLine_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__getParameter_Servlet_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: getParameter_Servlet Read data from a querystring using getParameter()
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__getParameter_Servlet_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__getParameter_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__Property_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: Property Read data from a system property
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__Property_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__Property_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__connect_tcp_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: connect_tcp Read data using an outbound tcp connection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__connect_tcp_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__connect_tcp_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__getQueryString_Servlet_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: getQueryString_Servlet Parse id param out of the URL query string (without using getParameter())
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__getQueryString_Servlet_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__getQueryString_Servlet_81_base {

    public void action(String data, HttpServletRequest request, HttpServletResponse response) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__URLConnection_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: URLConnection Read data from a web server with URLConnection
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__URLConnection_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__URLConnection_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__database_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: database Read data from a database
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__database_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__database_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__PropertiesFile_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: PropertiesFile Read data from a .properties file (in property named data)
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__PropertiesFile_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__PropertiesFile_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE15_External_Control_of_System_or_Configuration_Setting__Environment_81_goodG2B.java
Label Definition File: CWE15_External_Control_of_System_or_Configuration_Setting.label.xml
Template File: sources-sink-81_goodG2B.tmpl.java
*/
/*
 * @description
 * CWE: 15 External Control of System or Configuration Setting
 * BadSource: Environment Read data from an environment variable
 * GoodSource: A hardcoded string
 * Sinks:
 *    BadSink : Set the catalog name with the value of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an abstract method
 *
 * */
package testcases.CWE15_External_Control_of_System_or_Configuration_Setting;

public class CWE15_External_Control_of_System_or_Configuration_Setting__Environment_81_goodG2B extends CWE15_External_Control_of_System_or_Configuration_Setting__Environment_81_base {

    public void action(String data) throws Throwable {
        Connection dbConnection = null;
        try {
            dbConnection = IO.getDBConnection();
            /* POTENTIAL FLAW: Set the catalog name with the value of data
             * allowing a nonexistent catalog name or unauthorized access to a portion of the DB */
            dbConnection.setCatalog(data);
        } catch (SQLException exceptSql) {
            IO.logger.log(Level.WARNING, ""Error getting database connection"", exceptSql);
        } finally {
            try {
                if (dbConnection != null) {
                    dbConnection.close();
                }
            } catch (SQLException exceptSql) {
                IO.logger.log(Level.WARNING, ""Error closing Connection"", exceptSql);
            }
        }
    }
}
",NoCWE
"/*
 * @description Public static fields should be marked final.  If they are not, they
 * may be manipulated in unexpected ways.
 *
 * This class contains the ""good"" version.
 * There is no need to implement the bad() and good() methods in this test case.
 *
 * */
package testcases.CWE500_Public_Static_Field_Not_Final;

public class CWE500_Public_Static_Field_Not_Final__String_01_good1 extends AbstractTestCaseClassIssueGood implements Cloneable {

    /* FIX: public static field marked final */
    public static final String DEFAULT_ERROR = ""The value you entered was not understood.  Please try again."";

    private void good1() {
        IO.writeLine(DEFAULT_ERROR);
    }

    public void good() {
        good1();
    }

    /* Below is the main(). It is only used when building this testcase on
     * its own for testing or for building a binary to use in testing binary
     * analysis tools. It is not used when compiling all the testcases as one
     * application, which is how source code analysis tools are tested.
	 */
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        mainFromParent(args);
    }
}
",NoCWE
